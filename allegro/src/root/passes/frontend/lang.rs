//! Module for the lexer and parser for `Lang`
//! WARNING: this file has been generated by
//! Hime Parser Generator 4.3.0

use std::io::Read;

use hime_redist::ast::AstNode;
use hime_redist::errors::ParseErrors;
use hime_redist::lexers::automaton::Automaton;
use hime_redist::lexers::impls::ContextFreeLexer;
use hime_redist::lexers::Lexer;
use hime_redist::parsers::lrk::LRkAutomaton;
use hime_redist::parsers::lrk::LRkParser;
use hime_redist::parsers::Parser;
use hime_redist::result::ParseResult;
use hime_redist::symbols::SemanticBody;
use hime_redist::symbols::SemanticElementTrait;
use hime_redist::symbols::Symbol;
use hime_redist::text::Text;
use hime_redist::tokens::TokenRepository;

/// Static resource for the serialized lexer automaton
const LEXER_AUTOMATON: &[u8] = include_bytes!("lang_lexer.bin");

/// The unique identifier for terminal `SEPARATOR`
pub const ID_TERMINAL_SEPARATOR: u32 = 0x0004;
/// The unique identifier for terminal `NUMBER`
pub const ID_TERMINAL_NUMBER: u32 = 0x0008;
/// The unique identifier for terminal `STRING`
pub const ID_TERMINAL_STRING: u32 = 0x0009;
/// The unique identifier for terminal `IDENTIFIER`
pub const ID_TERMINAL_IDENTIFIER: u32 = 0x000A;
/// The unique identifier for terminal `TYPE`
pub const ID_TERMINAL_TYPE: u32 = 0x000B;
/// The unique identifier for terminal `COMPARISON_OP`
pub const ID_TERMINAL_COMPARISON_OP: u32 = 0x000C;
/// The unique identifier for terminal `LOGICAL_OP`
pub const ID_TERMINAL_LOGICAL_OP: u32 = 0x000D;

/// The unique identifier for the default context
pub const CONTEXT_DEFAULT: u16 = 0;

/// The collection of terminals matched by this lexer
/// The terminals are in an order consistent with the automaton,
/// so that terminal indices in the automaton can be used to retrieve the terminals in this table
pub const TERMINALS: &[Symbol] = &[
    Symbol {
        id: 0x0001,
        name: "Îµ"
    },
    Symbol {
        id: 0x0002,
        name: "$"
    },
    Symbol {
        id: 0x0004,
        name: "SEPARATOR"
    },
    Symbol {
        id: 0x0008,
        name: "NUMBER"
    },
    Symbol {
        id: 0x0009,
        name: "STRING"
    },
    Symbol {
        id: 0x000A,
        name: "IDENTIFIER"
    },
    Symbol {
        id: 0x000B,
        name: "TYPE"
    },
    Symbol {
        id: 0x000C,
        name: "COMPARISON_OP"
    },
    Symbol {
        id: 0x000D,
        name: "LOGICAL_OP"
    },
    Symbol {
        id: 0x0027,
        name: "("
    },
    Symbol {
        id: 0x0028,
        name: ")"
    },
    Symbol {
        id: 0x0029,
        name: "*"
    },
    Symbol {
        id: 0x002B,
        name: "/"
    },
    Symbol {
        id: 0x002C,
        name: "+"
    },
    Symbol {
        id: 0x002D,
        name: "-"
    },
    Symbol {
        id: 0x002E,
        name: "thru"
    },
    Symbol {
        id: 0x0030,
        name: ":"
    },
    Symbol {
        id: 0x0032,
        name: "for"
    },
    Symbol {
        id: 0x0033,
        name: "in"
    },
    Symbol {
        id: 0x0035,
        name: "while"
    },
    Symbol {
        id: 0x0037,
        name: "do"
    },
    Symbol {
        id: 0x0039,
        name: "end"
    },
    Symbol {
        id: 0x003A,
        name: "else"
    },
    Symbol {
        id: 0x003C,
        name: "if"
    },
    Symbol {
        id: 0x003E,
        name: "print"
    },
    Symbol {
        id: 0x0041,
        name: ","
    },
    Symbol {
        id: 0x0043,
        name: "let"
    },
    Symbol {
        id: 0x0044,
        name: "of"
    }
];

/// Creates a new lexer
fn new_lexer<'a: 'b, 'b, 'c>(
    repository: TokenRepository<'a, 'b, 'c>,
    errors: &'c mut ParseErrors<'a>
) -> Lexer<'a, 'b, 'c> {
    let automaton = Automaton::new(LEXER_AUTOMATON);
    Lexer::ContextFree(ContextFreeLexer::new(repository, errors, automaton, 0x0004))
}

/// Static resource for the serialized parser automaton
const PARSER_AUTOMATON: &[u8] = include_bytes!("lang_parser.bin");

/// The unique identifier for variable `exp_atom`
pub const ID_VARIABLE_EXP_ATOM: u32 = 0x000E;
/// The unique identifier for variable `exp_factor`
pub const ID_VARIABLE_EXP_FACTOR: u32 = 0x000F;
/// The unique identifier for variable `exp_term`
pub const ID_VARIABLE_EXP_TERM: u32 = 0x0010;
/// The unique identifier for variable `exp_cond`
pub const ID_VARIABLE_EXP_COND: u32 = 0x0011;
/// The unique identifier for variable `range`
pub const ID_VARIABLE_RANGE: u32 = 0x0012;
/// The unique identifier for variable `exp`
pub const ID_VARIABLE_EXP: u32 = 0x0013;
/// The unique identifier for variable `pair_bind`
pub const ID_VARIABLE_PAIR_BIND: u32 = 0x0014;
/// The unique identifier for variable `pair_decl`
pub const ID_VARIABLE_PAIR_DECL: u32 = 0x0015;
/// The unique identifier for variable `iterable`
pub const ID_VARIABLE_ITERABLE: u32 = 0x0016;
/// The unique identifier for variable `for_loop`
pub const ID_VARIABLE_FOR_LOOP: u32 = 0x0017;
/// The unique identifier for variable `while_loop`
pub const ID_VARIABLE_WHILE_LOOP: u32 = 0x0018;
/// The unique identifier for variable `loop_stmt`
pub const ID_VARIABLE_LOOP_STMT: u32 = 0x0019;
/// The unique identifier for variable `if_block`
pub const ID_VARIABLE_IF_BLOCK: u32 = 0x001A;
/// The unique identifier for variable `if_stmt`
pub const ID_VARIABLE_IF_STMT: u32 = 0x001B;
/// The unique identifier for variable `print_stmt`
pub const ID_VARIABLE_PRINT_STMT: u32 = 0x001C;
/// The unique identifier for variable `stmt`
pub const ID_VARIABLE_STMT: u32 = 0x001D;
/// The unique identifier for variable `block`
pub const ID_VARIABLE_BLOCK: u32 = 0x001E;
/// The unique identifier for variable `param_decl`
pub const ID_VARIABLE_PARAM_DECL: u32 = 0x001F;
/// The unique identifier for variable `params`
pub const ID_VARIABLE_PARAMS: u32 = 0x0020;
/// The unique identifier for variable `function_decl`
pub const ID_VARIABLE_FUNCTION_DECL: u32 = 0x0021;
/// The unique identifier for variable `decl`
pub const ID_VARIABLE_DECL: u32 = 0x0022;
/// The unique identifier for variable `program`
pub const ID_VARIABLE_PROGRAM: u32 = 0x0023;


/// The collection of variables matched by this parser
/// The variables are in an order consistent with the automaton,
/// so that variable indices in the automaton can be used to retrieve the variables in this table
pub const VARIABLES: &[Symbol] = &[
    Symbol {
        id: 0x000E,
        name: "exp_atom"
    },
    Symbol {
        id: 0x000F,
        name: "exp_factor"
    },
    Symbol {
        id: 0x0010,
        name: "exp_term"
    },
    Symbol {
        id: 0x0011,
        name: "exp_cond"
    },
    Symbol {
        id: 0x0012,
        name: "range"
    },
    Symbol {
        id: 0x0013,
        name: "exp"
    },
    Symbol {
        id: 0x0014,
        name: "pair_bind"
    },
    Symbol {
        id: 0x0015,
        name: "pair_decl"
    },
    Symbol {
        id: 0x0016,
        name: "iterable"
    },
    Symbol {
        id: 0x0017,
        name: "for_loop"
    },
    Symbol {
        id: 0x0018,
        name: "while_loop"
    },
    Symbol {
        id: 0x0019,
        name: "loop_stmt"
    },
    Symbol {
        id: 0x001A,
        name: "if_block"
    },
    Symbol {
        id: 0x001B,
        name: "if_stmt"
    },
    Symbol {
        id: 0x001C,
        name: "print_stmt"
    },
    Symbol {
        id: 0x001D,
        name: "stmt"
    },
    Symbol {
        id: 0x001E,
        name: "block"
    },
    Symbol {
        id: 0x001F,
        name: "param_decl"
    },
    Symbol {
        id: 0x0020,
        name: "params"
    },
    Symbol {
        id: 0x0021,
        name: "function_decl"
    },
    Symbol {
        id: 0x0022,
        name: "decl"
    },
    Symbol {
        id: 0x0023,
        name: "program"
    },
    Symbol {
        id: 0x0038,
        name: "__V56"
    },
    Symbol {
        id: 0x003B,
        name: "__V59"
    },
    Symbol {
        id: 0x0040,
        name: "__V64"
    },
    Symbol {
        id: 0x0042,
        name: "__V66"
    },
    Symbol {
        id: 0x0046,
        name: "__V70"
    },
    Symbol {
        id: 0x0047,
        name: "__VAxiom"
    }
];

/// The collection of virtuals matched by this parser
/// The virtuals are in an order consistent with the automaton,
/// so that virtual indices in the automaton can be used to retrieve the virtuals in this table
pub const VIRTUALS: &[Symbol] = &[

];

/// Represents a set of semantic actions in this parser
pub trait Actions {
    /// The OnNumber semantic action
    fn on_number(&mut self, head: Symbol, body: &dyn SemanticBody);
    /// The OnString semantic action
    fn on_string(&mut self, head: Symbol, body: &dyn SemanticBody);
    /// The OnIdentifier semantic action
    fn on_identifier(&mut self, head: Symbol, body: &dyn SemanticBody);
    /// The OnBin semantic action
    fn on_bin(&mut self, head: Symbol, body: &dyn SemanticBody);
    /// The OnRange semantic action
    fn on_range(&mut self, head: Symbol, body: &dyn SemanticBody);
    /// The OnBind semantic action
    fn on_bind(&mut self, head: Symbol, body: &dyn SemanticBody);
    /// The OnFor semantic action
    fn on_for(&mut self, head: Symbol, body: &dyn SemanticBody);
    /// The OnWhile semantic action
    fn on_while(&mut self, head: Symbol, body: &dyn SemanticBody);
    /// The OnIf semantic action
    fn on_if(&mut self, head: Symbol, body: &dyn SemanticBody);
    /// The OnPrint semantic action
    fn on_print(&mut self, head: Symbol, body: &dyn SemanticBody);
    /// The OnFunc semantic action
    fn on_func(&mut self, head: Symbol, body: &dyn SemanticBody);
}

/// The structure that implements no action
pub struct NoActions {}

impl Actions for NoActions {
    fn on_number(&mut self, _head: Symbol, _body: &dyn SemanticBody) {}
    fn on_string(&mut self, _head: Symbol, _body: &dyn SemanticBody) {}
    fn on_identifier(&mut self, _head: Symbol, _body: &dyn SemanticBody) {}
    fn on_bin(&mut self, _head: Symbol, _body: &dyn SemanticBody) {}
    fn on_range(&mut self, _head: Symbol, _body: &dyn SemanticBody) {}
    fn on_bind(&mut self, _head: Symbol, _body: &dyn SemanticBody) {}
    fn on_for(&mut self, _head: Symbol, _body: &dyn SemanticBody) {}
    fn on_while(&mut self, _head: Symbol, _body: &dyn SemanticBody) {}
    fn on_if(&mut self, _head: Symbol, _body: &dyn SemanticBody) {}
    fn on_print(&mut self, _head: Symbol, _body: &dyn SemanticBody) {}
    fn on_func(&mut self, _head: Symbol, _body: &dyn SemanticBody) {}
}

/// Parses the specified string with this parser
#[must_use]
pub fn parse_str(input: &'static str) -> ParseResult<'static, '_, 'static> {
    let text = Text::from_str(input);
    parse_text(text, &mut NoActions {})
}

/// Parses the specified string with this parser
pub fn parse_str_with<'t>(input: &'static str, actions: &mut dyn Actions) -> ParseResult<'static, 't, 'static> {
    let text = Text::from_str(input);
    parse_text(text, actions)
}

/// Parses the specified string with this parser
#[must_use]
pub fn parse_string(input: String) -> ParseResult<'static, 'static, 'static> {
    let text = Text::from_string(input);
    parse_text(text, &mut NoActions {})
}

/// Parses the specified string with this parser
pub fn parse_string_with(input: String, actions: &mut dyn Actions) -> ParseResult<'static, 'static, 'static> {
    let text = Text::from_string(input);
    parse_text(text, actions)
}

/// Parses the specified stream of UTF-8 with this parser
///
/// # Errors
///
/// Return an `std::io::Error` when reading the stream as UTF-8 fails
pub fn parse_utf8_stream(input: &mut dyn Read) -> Result<ParseResult<'static, 'static, 'static>, std::io::Error> {
    let text = Text::from_utf8_stream(input).unwrap();
    Ok(parse_text(text, &mut NoActions {}))
}

pub fn parse_utf8_stream_with(input: &mut dyn Read, actions: &mut dyn Actions) -> ParseResult<'static, 'static, 'static> {
    let text = Text::from_utf8_stream(input).unwrap();
    parse_text(text, actions)
}

/// Parses the specified text with this parser
fn parse_text(text: Text<'static>, actions: &mut dyn Actions) -> ParseResult<'static, 'static, 'static> {
    parse_text_with(text.clone(), TERMINALS, VARIABLES, VIRTUALS, actions)
}

/// Parses the specified text with this parser
fn parse_text_with<'s, 't, 'a>(
    text: Text<'t>,
    terminals: &'a [Symbol<'s>],
    variables: &'a [Symbol<'s>],
    virtuals: &'a [Symbol<'s>],
    actions: &mut dyn Actions
) -> ParseResult<'s, 't, 'a> {
    let mut my_actions = |index: usize, head: Symbol, body: &dyn SemanticBody| match index {
        0 => actions.on_number(head, body),
        1 => actions.on_string(head, body),
        2 => actions.on_identifier(head, body),
        3 => actions.on_bin(head, body),
        4 => actions.on_range(head, body),
        5 => actions.on_bind(head, body),
        6 => actions.on_for(head, body),
        7 => actions.on_while(head, body),
        8 => actions.on_if(head, body),
        9 => actions.on_print(head, body),
        10 => actions.on_func(head, body),
        _ => ()
    };

    let mut result = ParseResult::new(terminals, variables, virtuals, text);
    {
        let data = result.get_parsing_data();
        let mut lexer = new_lexer(data.0, data.1);
        let automaton = LRkAutomaton::new(PARSER_AUTOMATON);
        let mut parser = LRkParser::new(&mut lexer, automaton, data.2, &mut my_actions);
        parser.parse();
    }
    result
}

/// Visitor interface
pub trait Visitor {
    fn on_terminal_separator(&self, _node: &AstNode) {}
    fn on_terminal_number(&self, _node: &AstNode) {}
    fn on_terminal_string(&self, _node: &AstNode) {}
    fn on_terminal_identifier(&self, _node: &AstNode) {}
    fn on_terminal_type(&self, _node: &AstNode) {}
    fn on_terminal_comparison_op(&self, _node: &AstNode) {}
    fn on_terminal_logical_op(&self, _node: &AstNode) {}
    fn on_variable_exp_atom(&self, _node: &AstNode) {}
    fn on_variable_exp_factor(&self, _node: &AstNode) {}
    fn on_variable_exp_term(&self, _node: &AstNode) {}
    fn on_variable_exp_cond(&self, _node: &AstNode) {}
    fn on_variable_range(&self, _node: &AstNode) {}
    fn on_variable_exp(&self, _node: &AstNode) {}
    fn on_variable_pair_bind(&self, _node: &AstNode) {}
    fn on_variable_pair_decl(&self, _node: &AstNode) {}
    fn on_variable_iterable(&self, _node: &AstNode) {}
    fn on_variable_for_loop(&self, _node: &AstNode) {}
    fn on_variable_while_loop(&self, _node: &AstNode) {}
    fn on_variable_loop_stmt(&self, _node: &AstNode) {}
    fn on_variable_if_block(&self, _node: &AstNode) {}
    fn on_variable_if_stmt(&self, _node: &AstNode) {}
    fn on_variable_print_stmt(&self, _node: &AstNode) {}
    fn on_variable_stmt(&self, _node: &AstNode) {}
    fn on_variable_block(&self, _node: &AstNode) {}
    fn on_variable_param_decl(&self, _node: &AstNode) {}
    fn on_variable_params(&self, _node: &AstNode) {}
    fn on_variable_function_decl(&self, _node: &AstNode) {}
    fn on_variable_decl(&self, _node: &AstNode) {}
    fn on_variable_program(&self, _node: &AstNode) {}
}

/// Walk the AST of a result using a visitor
pub fn visit(result: &ParseResult, visitor: &dyn Visitor) {
    let ast = result.get_ast();
    let root = ast.get_root();
    visit_ast_node(root, visitor);
}

/// Walk the sub-AST from the specified node using a visitor
pub fn visit_ast_node(node: AstNode, visitor: &dyn Visitor) {
    let children = node.children();
    for child in children.iter() {
        visit_ast_node(child, visitor);
    }
    match node.get_symbol().id {
        0x0004 => visitor.on_terminal_separator(&node),
        0x0008 => visitor.on_terminal_number(&node),
        0x0009 => visitor.on_terminal_string(&node),
        0x000A => visitor.on_terminal_identifier(&node),
        0x000B => visitor.on_terminal_type(&node),
        0x000C => visitor.on_terminal_comparison_op(&node),
        0x000D => visitor.on_terminal_logical_op(&node),
        0x000E => visitor.on_variable_exp_atom(&node),
        0x000F => visitor.on_variable_exp_factor(&node),
        0x0010 => visitor.on_variable_exp_term(&node),
        0x0011 => visitor.on_variable_exp_cond(&node),
        0x0012 => visitor.on_variable_range(&node),
        0x0013 => visitor.on_variable_exp(&node),
        0x0014 => visitor.on_variable_pair_bind(&node),
        0x0015 => visitor.on_variable_pair_decl(&node),
        0x0016 => visitor.on_variable_iterable(&node),
        0x0017 => visitor.on_variable_for_loop(&node),
        0x0018 => visitor.on_variable_while_loop(&node),
        0x0019 => visitor.on_variable_loop_stmt(&node),
        0x001A => visitor.on_variable_if_block(&node),
        0x001B => visitor.on_variable_if_stmt(&node),
        0x001C => visitor.on_variable_print_stmt(&node),
        0x001D => visitor.on_variable_stmt(&node),
        0x001E => visitor.on_variable_block(&node),
        0x001F => visitor.on_variable_param_decl(&node),
        0x0020 => visitor.on_variable_params(&node),
        0x0021 => visitor.on_variable_function_decl(&node),
        0x0022 => visitor.on_variable_decl(&node),
        0x0023 => visitor.on_variable_program(&node),
        _ => ()
    };
}
