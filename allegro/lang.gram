grammar Lang 
{
    options
    {
        Axiom = "program"; // Root Rule
        Separator = "SEPARATOR"; // whitespace terminal
        ParserType = "LR";
        Runtime = "Rust";
        CompilationMode = "Debug";
    }
    terminals
    {
        WHITE_SPACE -> U+0020 | U+0009 | U+000B | U+000C | '\n' | '\r';
        SEPARATOR   -> WHITE_SPACE+;

        ALPHA -> [a-z] | [A-Z];

        INTEGER     -> [0-9] [0-9]* | '0' ;
        FLOAT        -> INTEGER? '.' INTEGER  (('e' | 'E') ('+' | '-')? INTEGER)?
                    |  INTEGER ('e' | 'E') ('+' | '-')? INTEGER ;
        NUMBER      -> INTEGER | FLOAT ;

        STRING -> '"' ( .* - (.* '"' .*) ) '"';

        IDENTIFIER -> ('_' | ALPHA) (ALPHA | '_')* (ALPHA | [0-9] | '_')*;

        TYPE -> 'int' | 'flt' | 'bool' | 'str' | '..';

        COMPARISON_OP -> '>' | '>=' | '<' | '<=' | '==' | '!=';

        LOGICAL_OP -> 'and' | 'or' | 'not';

    }
rules
  {

    //statement_end -> ';' | '\n' | '\r' '\n';

    exp_atom   -> NUMBER^ @OnNumber
              | STRING^ @OnString
              | IDENTIFIER^ @OnIdentifier
              | '('! exp^ ')'!;

    exp_factor -> exp_atom^
              |  exp_factor '*'^ exp_atom @OnBin
              |  exp_factor '/'^ exp_atom @OnBin;
    exp_term   -> exp_factor^
              |  exp_term '+'^ exp_factor @OnBin
              |  exp_term '-'^ exp_factor @OnBin;

    exp_cond ->  exp_term COMPARISON_OP^ exp_term | exp_atom^;

    range -> NUMBER 'thru'! NUMBER;

    exp        -> exp_term^;

    pair_bind -> IDENTIFIER^ ':'! exp @OnBind;

    pair_decl -> IDENTIFIER^ ':'! TYPE @OnBind;

    iterable -> IDENTIFIER | range ;

    for_loop -> 'for'! IDENTIFIER 'in'! iterable block ;

    while_loop -> 'while'! exp_cond block ;

    loop_stmt -> (while_loop | for_loop)^;

    if_block -> 'do'! stmt+ ('end'! | 'else'! 'do'! stmt+  'end'!) ;

    if_stmt -> 'if'! exp if_block ;

    print_stmt -> 'print' exp;

    stmt -> (pair_bind | pair_decl | if_stmt | print_stmt | loop_stmt)^ ;

    block -> 'do'! stmt+ 'end'! ;

    param_decl -> IDENTIFIER^ ':'! TYPE ;

    params -> '('! (param_decl ','!)* param_decl ')'! | '('! ')'! ;

    function_decl -> 'let'! IDENTIFIER 'of'! params block;

    decl -> (function_decl)^;

    program -> decl+;
  }
}